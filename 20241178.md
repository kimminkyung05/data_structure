#LeetCode 225

``` python 
from collections import deque
class MyStack:

    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()

    def push(self, x):
        self.q2.append(x)
        while self.q1:
            self.q2.append(self.q1.popleft())
        self.q1, self.q2 = self.q2, self.q1

    def pop(self):
        return self.q1.popleft()

    def top(self):
        return self.q1[0]

    def empty(self):
        return not self.q1
```

LeetCode 232
```python

class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x):
        self.s1.append(x)

    def pop(self):
        self.move()
        return self.s2.pop()

    def peek(self):
        self.move()
        return self.s2[-1]

    def empty(self):
        return not self.s1 and not self.s2

    def move(self):
        if not self.s2:
            while self.s1:
                self.s2.append(self.s1.pop())

```

교재 큐 연습 문제

연습문제 01 
```python
class ListQueue :

  def __init__(self):
    self.__queue=[]

  def enqueue(self,x):
    self.__queue.insert(0,x)

  def dequeue(self):
    return self.__queue.pop()

  def front(self):
    if self.isEmpty():
        	return None
    return self.__queue[-1]

  def isEmpty(self):
    return len(self.__queue)==0

  def dequeueAll(self):
    self.__queue.clear()
```
연습문제 02
```python
def is_in_set(string) -> bool:
    if '$' not in string:
        return False

    q = ListQueue()
    index = 0

    while string[index] != '$':
        q.enqueue(string[index])
        index += 1

    index += 1

    while index < len(string):
        if q.isEmpty():
            return False
        if q.dequeue() != string[index]:
            return False
        index += 1

    return q.isEmpty()
```
연습문제 03
```python
def copy_linked(a, b):
    b.dequeue_all()
    temp_queue = LinkedQueue()

    size = a.size()

    for _ in range(size):
        item = a.dequeue()
        temp_queue.enqueue(item)
        a.enqueue(item)

    while not temp_queue.is_empty():
        b.enqueue(temp_queue.dequeue())
```
연습문제 04
```python
def push(q1, q2, item):
    q2.dequeue_all()
    while not q1.is_empty():
        q2.enqueue(q1.dequeue())

    q1.enqueue(item)

    while not q2.is_empty():
        q1.enqueue(q2.dequeue())


def pop(q1, q2):
    q2.dequeue_all()
    count = 0

    while not q1.is_empty():
        q2.enqueue(q1.dequeue())
        count += 1

    for _ in range(count - 1):
        q1.enqueue(q2.dequeue())

    return q2.dequeue()
```
연습문제 05
```python

def enqueue(s1, s2, item):
    s2.pop_all()

    while not s1.is_empty():
        s2.push(s1.pop())

    s1.push(item)

    while not s2.is_empty():
        s1.push(s2.pop())


def dequeue(s1, s2):
    s2.pop_all()

    while not s1.is_empty():
        s2.push(s1.pop())

    ret_item = s2.pop()

    while not s2.is_empty():
        s1.push(s2.pop())

    return ret_item
```
연습문제 06

Θ(1) , Θ(1)

각 연산은 오직 하나의 노드에 대해서만 포인터를 수정하거나 접근하기 때문에, 시간 복잡도는 각각 Θ(1) 이라고 할 수 있다.

연습문제 07
Θ(n), Θ(n) 
단방향 연결 리스트를 기반으로 한 Deque는 Θ(1) 혹은 Θ(n)의 시간 복잡도를 가진다. 최악의 경우를 고려하면, enqueue()와 dequeue() 연산 모두 Θ(n)의 수행 시간을 갖는다.

연습문제 08
```python
class ListDeque:
    def __init__(self):
        self.__queue = []

    def enqueue(self, x):
        self.__queue.append(x)

    def dequeue(self):
        return self.__queue.pop(0)

    def push(self, x):
        self.__queue.insert(0, x)

    def pop(self):
        return self.__queue.pop()

    def front(self):
        if self.is_empty():
            return None
        else:
            return self.__queue[0]

    def rear(self):
        if self.is_empty():
            return None
        else:
            return self.__queue[-1]

    def is_empty(self):
        return not bool(self.__queue)

    def dequeue_all(self):
        self.__queue.clear()

    def print_deque(self):
        print("Deque from front:", end=' ')
        for x in self.__queue:
            print(x, end=' ')
        print()
```
